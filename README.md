panda
=====

In Jenkins, one deals with jobs, their parameters, their orchestration, their duplication between branches (using templating or not), the duplication of their orchestration, etc. In the Jenkins core, not much of this is available. One would need to install plug-ins, update ones or even create some from scratch. And then make them work together.

My feeling is that the idea of a pipeline should be central to the continuous integration.

The idea behind `panda` (1) is to be able to support pipelines.

One would define a `pipeline` in Panda with a given set of parameters. It would be associated with `stages` that are run in sequence, automatically, manually or conditionally (using triggers).

Stages are groups of jobs that are either run in parallel or in sequence. Each job accepts a subset of the parameters defined by the pipeline. A job can be linked to a real (remote) Jenkins job, or be anything else.

A pipeline can be defined with a default set of parameters, but `branches` can be defined as other sets of parameters.

One can run a pipeline for a given branch or the default branch. The input parameters can be overridden if needed. The outcome of such a run is designed as a `(pipeline) instance`. This `instance` will go through each stage, running all the associated jobs.

A dashboard per pipeline and branch allows to see at one glance the status of the last instances. From there, one can triggers the next manual stages if available.

# Instance life-cycle

When an authorized user creates an instance for a pipeline, he has to select the branch he wants this instance for, and fill in parameters that are either required or allowed to be overridden.

Therefore, an instance is the association of the branch of a pipeline and a set of parameter values. The branch can also be the default one for the pipeline.

Before even starting its life, one instance can be associated with extra parameters. Those parameters are generated by _instance parameters contributors_ extensions. A typical example is the attribution of a _version_ parameter to the instance. This is such a classic example that such an extension is built-in in the core code.

Once the instance is fully parametrized, it is eligible for run.

An instance is eligible for run if:
* its set of parameters is complete
* it is not currently running

Once an instance is selected for run by the _instance runner_, the next available stage is computed and activated in the _stage runner_. All jobs defined by this stage are run, in parallel or in sequence, according the stage settings, by the _job runner_.

Once all the jobs are complete, the stage is marked as well as complete. The _status_ of the stage depends on all the _statuses_ of its jobs. Typically, a stage is marked as Success if all its jobs have also the Success status.

In the end, the instance is back into the instance runner and the subsequent stages can be activated.

Several points must be noted here:
* the creation of an instance can be triggered automatically (see _Triggers_)
* the first stage of an instance is always triggered automatically
* the subsequent stages of an instance are triggered according to the settings of the stage:
  * manual
  * automatic
  * custom trigger

---
(1) Probably a temporary name for this project... The idea came after a discussion - maybe an explanation could come later.
